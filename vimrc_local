mapclear

" first the disabled features due to security concerns
set modelines=0         " no modelines, see http://www.guninski.com/vim1.html
"let g:secure_modelines_verbose=1 " securemodelines vimscript


set autoindent          " always set autoindenting on
set autoread                    " watch for file changes by other programs
set backspace=indent,eol,start
set backup
set backupext=.bak
set hlsearch
set hidden                      " allow editing multiple unsaved buffers
set ignorecase
set incsearch                  " show matches as soon as possible
set noautowrite                 " don't automatically write on :next, etc
set nocompatible                " vim defaults, not vi!
set nrformats-=octal            " Don't consider numbers starting with 0 as octal when incrementing/decrementing via c-a, c-x
set ruler
set scrolloff=5                 " keep at least 5 lines above/below cursor
set sidescrolloff=5             " keep at least 5 columns left/right of cursor
set shiftwidth=2
set showbreak=>\ 
set showcmd             " Show (partial) command in status line.
set smartcase
set nostartofline         " Do not go to first character of line when changing buffers.
set tabstop=2
set undolevels=1000             " number of forgivable mistakes

set path=. " the default of path includes '/usr/include'. I do not want this.

"autocomplete like the bash
"chance completemode to get a more natural feeling
"see http://vim.wikia.com/wiki/Make_Vim_completion_popup_menu_work_just_like_in_an_IDE
set wildmode=longest,list 
set completeopt=longest,menuone

" Ohne Menus
set guioptions=aeiM
" Keine Dialoge
set guioptions+=c

" Prevent DrChip menu
let g:DrChipTopLvlMenu = ""

" Statusline:
set statusline=%<%f\ %h%y%m%r%=%-14.(%l,%c%V%)\ %P
set laststatus=2

syn on
colorscheme PapayaWhip
" Customize Color scheme
highlight FoldColumn guibg=Moccasin guifg=Red gui=bold
hi DiffChange guibg=LightBlue ctermbg=DarkCyan ctermfg=White
hi DiffText gui=NONE guibg=LightRed ctermbg=DarkCyan ctermfg=Yellow

if !has('gui_running')
	if $TERM == "xterm"
		set t_Co=256
		hi Normal ctermbg=223
		" Set cursor color:
		silent !echo -ne "\033]12;RoyalBlue1\007"
	else
		hi Normal ctermbg=7
	end
end


filetype plugin on


"""""""""""""""""""""""""""
"""" Latex-Suite Stuff.
"""""""""""""""""""""""""""
" IMPORTANT: grep will sometimes skip displaying the file name if you
" search in a singe file. This will confuse Latex-Suite. Set your grep
" program to always generate a file-name.
set grepprg=grep\ -nH\ $*

" OPTIONAL: This enables automatic indentation as you type.
filetype indent on

" OPTIONAL: Starting with Vim 7, the filetype of empty .tex files defaults to
" 'plaintex' instead of 'tex', which results in vim-latex not being loaded.
" The following changes the default filetype back to 'tex':
let g:tex_flavor='latex'


" No spell-checking in tex comments (see syntax/tex.vim)
let g:tex_comment_nospell = 1


"" Mit <C-C> Einrückungen löschen. (mit <C-T> hinzufügen).
inoremap <C-C> <C-D>

" <C-J> auf <C-D> ummappen (Jump zum <++>)
" In  Normal, insert
imap <C-D> <Plug>IMAP_JumpForward
nmap <C-D> <Plug>IMAP_JumpForward
vmap <C-D> <Plug>IMAP_JumpForward



"tabulator um durch den buffer zu wechseln
nnoremap <silent> <C-Tab> :bnext<CR>
nnoremap <silent> <S-C-Tab> :bprevious<CR>


" Disable auto-comment in C,cpp with the // comments.
au FileType c,cpp setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,f://
" was: comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,://


""" Enhanced Commentify:
" Nice indentation:
let EnhCommentifyRespectIndent = 'yes'
let EnhCommentifyPretty = 'yes'
let EnhCommentifyUseBlockIndent = 'yes'
" Use large comment blocks
let EnhCommentifyMultiPartBlocks = 'yes'
" Own Bindings
let EnhCommentifyUserBindings = 'yes'
" Für Markierungen und sowas wie 3<C-C> im Normalmodus:
nmap <silent> <c-c> :MyEnhancedCommentify<CR>
vmap <silent> <c-c> :MyEnhancedCommentify<CR>
command! -range MyEnhancedCommentify call EnhancedCommentify('yes', 'first', <line1>, <line2>)

" show tabs:?
set list
set listchars=tab:\|\ 


"" Header gates einfügen:
function! s:insert_gates()
  let gatename = substitute(toupper(expand("%:t")), "\\.", "_", "g")
  execute "normal! i#ifndef " . gatename
  execute "normal! o#define " . gatename
  execute "normal! Go#endif /* " . gatename . " */"
  normal! kk
endfunction

autocmd BufNewFile *.{h,hpp} call <SID>insert_gates()

" Alt-P in insert-mode: insert register 0
imap <a-p> <c-r>0


" SVN-diff??
map <silent> <F10> :call Show_svn_diff()<cr>gg
function Show_svn_diff()
	let filename=expand("%")
	let is_svn=isdirectory(expand('%:h').'/.svn')
	new
	if is_svn
		exe "0read !svn diff ".filename
	else
		exe "0read !git diff HEAD ".filename
	end
	set syntax=diff buftype=nofile
	setlocal nomodifiable
	setlocal bufhidden=delete
	nmap <silent><buffer> <c-c> :bdel<cr>
endfunction

map <silent> <S-F10> :call Show_full_svn_diff()<cr>gg
function Show_full_svn_diff()
	let is_svn=isdirectory(expand('%:h').'/.svn')
	" Save filetype
	let ft=&ft
	diffthis
	if is_svn
		let filename=expand("%")
		rightb vnew
		exe "0read !svn cat ".filename
	else
		let opwd=getcwd()
		let dirname=expand("%:h")
		let filename=expand("%:t")
		rightb vnew
		" Change into directory of file and back, since git has to be invoked
		" inside the git tree.
		exec 'lcd ' . dirname
		exe "0read !git show HEAD:$(relpath $(git rev-parse --show-toplevel) ".filename . ")"
		exec 'lcd ' . opwd
	end
	normal jdd
	setlocal buftype=nofile
	setlocal nomodifiable
	setlocal bufhidden=delete
	" Apply filetype
	exec 'setlocal ft=' . ft
	diffthis
	autocmd BufDelete <buffer> diffoff!
	nmap <silent><buffer> <c-c> :bdel<cr>
endfunction





"""""""""""""""""""""""
" Spellchecker
"""""""""""""""""""""""

let spellst=["de", "en"]

function Sel_lang()
        let g:langcnt = (g:langcnt+1) % len (g:spellst)
        let lang = g:spellst[g:langcnt]
        echo "spelllang = " . lang
        exe "set spelllang=".lang
endfunction 

let langcnt=0
set spelllang="en"

" F2 - Spellcheck an/aus
map <silent> <F2> :set spell!<CR>:echo "Spell check: " . strpart("offon", 3 * &spell, 3)<cr>
" F3 - Sprache Ändern
map <silent> <F3> :call Sel_lang() <CR>

"""""""""""""""""""""""
" END Spellchecker
"""""""""""""""""""""""


" Speichern mit <c-s>
map <c-s> :w<cr>
imap <c-s> <c-o>:w<cr>


" Redefine 'Y' such that it behaves like 'D' and 'C'
map Y y$

" Move to the last known cursor position and unfold it.
au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif
au BufReadPost * normal! zv


" Space in normal-mode => toggle folding (if there is a fold)
nnoremap <silent> <Space> @=(foldlevel('.')?'za':'l')<CR>

" Shift-Space in normal-mode => close fold (if there is a fold)
nnoremap <silent> <S-Space> @=(foldlevel('.')?'zc':'l')<CR>


" shift + insert -> paste in clip board
inoremap <S-Insert> <C-R>*


" Mapping für HiLinkTrace
map <unique> <Leader>hlt <Plug>HiLinkTrace




"""""""""""""""
" Mappings for the swap words plugin
"""""""""""""""
vmap <silent> gs <Plug>SwapWords
nmap <silent> gs <Plug>SwapWords

map <silent> gS <Plug>ResetSwapWords


"""""""""""""""
" Implementation of g/
" Search for the next motion.
"""""""""""""""

" Mapping: use the selection
vmap <silent> g/ <esc>:call SearchMotion("visual")<CR>

" Mapping: use a text object
nmap <silent> g/ :set operatorfunc=SearchMotion<CR>g@

function SearchMotion( mode )
	if a:mode == "visual"
		let startpos = getpos("'<")
		let endpos = getpos("'>")
	elseif a:mode == "char"
		let startpos = getpos("'[")
		let endpos = getpos("']")
	else
		exit
	end

	" Only work within one line
	if startpos[1] == endpos[1]
		let line = getline(startpos[1])
		let wordStart = startpos[2]-1
		let wordEnd = endpos[2]-1
		let word = line[(wordStart):(wordEnd)]
		" call search(word)
		" call matchadd('search', word)
		call histadd('search', word)
		let @/=word
		" if &hlsearch
		" 	echomsg "bla"
		" 	set hlsearch
		" end
		" normal n
		" let b:searchedWord = word
	end
endfunction


" Write with sudo (if you forgot to start vim as root)
" % is replaced by current file name
command Sudow w !sudo tee % > /dev/null
